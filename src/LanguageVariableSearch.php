<?php

/**
 * Contao Language editor
 *
 * @package    Language Editor
 * @author     David Molineus <david.molineus@netzmacht.de>
 * @copyright  2012 InfinitySoft 2012
 * @copyright  2015-2019 netzmacht David Molineus
 * @license    LGPL-3.0-or-later https://github.com/netzmacht/contao-language-editor/blob/master/LICENSE
 * @filesource
 */

namespace Netzmacht\Contao\LanguageEditor;

use Contao\CoreBundle\Config\ResourceFinder;
use Contao\System;
use File;

/**
 * Class LanguageVariableSearch is the backend module handling the search request
 */
class LanguageVariableSearch
{
    /**
     * The language editor.
     *
     * @var LanguageEditor
     */
    protected $languageEditor;

    /**
     * Language variable keys.
     *
     * @var array
     */
    protected $languageVariableKeys;

    /**
     * Construct.
     */
    public function __construct()
    {
        $this->languageEditor = LanguageEditor::getInstance();
    }

    /**
     * Search for language variables.
     *
     * @return string
     *
     * @SuppressWarnings(PHPMD.Superglobals)
     */
    public function searchLanguageVariable()
    {
        $template = new \BackendTemplate('be_translation_search');

        if (\Input::post('FORM_SUBMIT') == 'tl_translation_search') {
            if (\Input::get('back')) {
                \Controller::redirect('contao/main.php?do=language-editor&key=search');
            }

            $_SESSION['tl_translation_search_keyword']     = \Input::post('keyword');
            $_SESSION['tl_translation_search_language']    = \Input::post('language');
            $_SESSION['tl_translation_search_translation'] = \Input::post('translation');

            $keyword      = html_entity_decode(\Input::post('keyword'), (ENT_QUOTES | ENT_HTML401), 'UTF-8');
            $language     = \Input::post('language');
            $translations = $this->getTranslationsFromRequest();

            $result      = array();
            $results     = 0;
            $keywordRgxp = $this->getKeywordRegexp($keyword);

            $start = time();
            $end   = $this->calculateEndTime($start);
            $count = count($translations);

            while (time() < $end && $count && !$results) {
                $translation          = array_shift($translations);
                $count                = count($translations);
                $result[$translation] = array();

                \Controller::loadLanguageFile(
                    $this->languageEditor->getLanguageFileName($translation),
                    $language,
                    true
                );

                if ($this->existsTranslation($translation)) {
                    foreach (array_keys($GLOBALS['TL_TRANSLATION'][$translation]) as $path) {
                        $value = $this->languageEditor->getLangValue($GLOBALS['TL_LANG'], explode('|', $path), true);

                        $this->matchResults($value, $keywordRgxp, $result, $results, $translation, $path);
                    }
                }
            }

            $template->translations = $translations;
            $template->result       = $result;
        } else {
            if (!isset($_SESSION['tl_translation_search_language'])) {
                $_SESSION['tl_translation_search_language'] = $GLOBALS['TL_LANGUAGE'];
            }

            $template->translations = array_keys($GLOBALS['TL_TRANSLATION']);
        }

        return $template->parse();
    }

    /**
     * Build language variables key files.
     *
     * @return string
     *
     * @SuppressWarnings(PHPMD.Superglobals)
     * @SuppressWarnings(PHPMD.ExitExpression)
     */
    public function buildLanguageVariableKeys()
    {
        $template = new \BackendTemplate('be_translation_search_build_keys');

        if (\Input::post('FORM_SUBMIT') == 'tl_translation_search_build_keys') {
            $this->cleanTranslationFiles();

            $template->translations = $this->getTranslations();

            if (!$template->translations) {
                $_SESSION['TL_INFO'][] = $GLOBALS['TL_LANG']['tl_translation']['nothingtodo'];
                \Controller::reload();
            }
        } elseif (\Input::get('translation')) {
            // get the next translation group
            $translation = \Input::get('translation');

            $file = new File('system/languages/langkeys.' . $translation . '.php');
            $file->write("<?php if (!defined('TL_ROOT')) die('You can not access this file directly!');

/**
 * DO NOT MODIFY THIS FILE, IT IS GENERATED BY THE LANGUAGE EDITOR!
 */
");

            // load the language
            \Controller::loadLanguageFile($this->languageEditor->getLanguageFileName($translation));

            if (is_array($GLOBALS['TL_LANG'][$translation])) {
                $this->languageVariableKeys = array();

                $this->buildLanguageVariableKeysFrom(
                    $translation,
                    $translation,
                    $GLOBALS['TL_LANG'][$translation]
                );

                ksort($this->languageVariableKeys);

                foreach ($this->languageVariableKeys as $translation => $v) {
                    foreach ($v as $path => $config) {
                        $key   = sprintf('$GLOBALS[\'TL_TRANSLATION\'][\'%s\'][\'%s\']', $translation, $path);
                        $value = var_export($config, true);

                        $file->append($key . ' = ' . $value . ";\n");
                    }
                }
            }

            $file->close();

            header('Content-Type: image/png');
            $handle = fopen(TL_ROOT . '/system/modules/language-editor/html/complete.png', 'rb');
            fpassthru($handle);
            fclose($handle);
            exit;
        } else {
            // get translation keys found by the TranslationSearch::buildTranslationKeys method
            $files = new \RegexIterator(
                new \DirectoryIterator(TL_ROOT . '/system/languages/'),
                '#^langkeys\..*\.php$#'
            );

            foreach ($files as $file) {
                require_once($file->getPathname());
            }
        }

        return $template->parse();
    }

    /**
     * Build language variable keys.
     *
     * @param string $translation The translation key.
     * @param string $path        The translation path.
     * @param string $language    The language.
     *
     * @return void
     *
     * @SuppressWarnings(PHPMD.Superglobals)
     */
    protected function buildLanguageVariableKeysFrom($translation, $path, $language)
    {
        if (!isset($GLOBALS['TL_TRANSLATION'][$translation][$path])) {
            if (!is_array($language)) {
                $this->languageVariableKeys[$translation][$path] = array(
                    'type' => 'text'
                );
            } elseif (array_is_assoc($language) || count($language) > 2) {
                foreach ($language as $k => $v) {
                    $this->buildLanguageVariableKeysFrom($translation, $path . '|' . $k, $v);
                }
            } else {
                $this->languageVariableKeys[$translation][$path] = array(
                    'type' => 'inputField'
                );
            }
        }
    }

    /**
     * Get all available translations based on the used language files.
     *
     * @return array
     */
    protected function getTranslations()
    {
        $translations = array();

        // walk over modules and find translations
        /** @var ResourceFinder $finder */
        $finder = System::getContainer()->get('contao.resource_finder');
        $paths  = $finder->findIn('languages/')->files()->name('/\.(php|xlf)$/');

        foreach ($paths as $file) {
            if (preg_match('#/languages/\w\w/([^/]+)\.(php|xlf)#', $file->getPathname(), $match)
                && !in_array($match[1], array('countries', 'default', 'explain', 'languages', 'modules'))
                && !in_array($match[1], $translations)
            ) {
                $translations[] = $match[1];
            }
        }

        sort($translations);

        // add defaults
        $translations = array_merge(
            $translations,
            array_keys(LanguageEditor::$defaultGroups)
        );

        $temp = array();
        foreach ($translations as $translation) {
            if (!is_file(TL_ROOT . '/system/languages/langkeys.' . $translation . '.php')) {
                $temp[] = $translation;
            }
        }

        return $temp;
    }

    /**
     * Get keyword regexp.
     *
     * @param string $keyword The search keyword.
     *
     * @return string
     */
    private function getKeywordRegexp($keyword)
    {
        $fullMatch = strpos($keyword, '*') !== false;

        $regexp  = '#' . ($fullMatch ? '^' : '');
        $regexp .= implode(
            '.*',
            array_map('preg_quote', explode('*', $keyword))
        );

        $regexp .= ($fullMatch ? '$' : '') . '#i';

        return $regexp;
    }

    /**
     * Match search results.
     *
     * @param mixed  $value       The value to search.
     * @param string $keywordRgxp The regex for the current keyword.
     * @param array  $result      The result array.
     * @param int    $results     The counted results.
     * @param string $translation The translation domain.
     * @param string $path        The translation path.
     *
     * @return void
     */
    private function matchResults($value, $keywordRgxp, &$result, &$results, $translation, $path)
    {
        if (!is_array($value)) {
            if (preg_match($keywordRgxp, $value)
                || preg_match($keywordRgxp, strip_tags($value))) {
                $result[$translation][$path] = $value;
                $results ++;
            }

            return;
        }

        foreach ($value as $v) {
            $this->matchResults($v, $keywordRgxp, $result, $results, $translation, $path);
        }
    }

    /**
     * Get the translations from the http request.
     *
     * @return array
     *
     * @SuppressWarnings(PHPMD.Superglobals)
     */
    private function getTranslationsFromRequest()
    {
        return \Input::post('translation')
            ? array(\Input::post('translation'))
            : (\Input::post('translations')
            ? explode(',', \Input::post('translations'))
            : array_keys($GLOBALS['TL_TRANSLATION'])
        );
    }

    /**
     * Calculate the end time of the timeout depending on start time and max execition time.
     *
     * @param int $start The start timestamp.
     *
     * @return string
     */
    private function calculateEndTime($start)
    {
        $end = ini_get('max_execution_time');

        if ($end > 0) {
            $end = ($start + 0.75 * $end);

            return $end;
        } else {
            $end = ($start + 30);

            return $end;
        }
    }

    /**
     * Check if an translation exists as language and translation keys.
     *
     * @param string $translation The translation domain.
     *
     * @return bool
     *
     * @SuppressWarnings(PHPMD.Superglobals)
     */
    private function existsTranslation($translation)
    {
        return isset($GLOBALS['TL_LANG'][$translation]) && isset($GLOBALS['TL_TRANSLATION'][$translation]);
    }

    /**
     * Clean the translation file if the post param clean is given.
     *
     * @return void
     */
    private function cleanTranslationFiles()
    {
        // clean old files
        if (\Input::post('clean')) {
            $files = new \RegexIterator(
                new \DirectoryIterator(TL_ROOT . '/system/languages/'),
                '#^langkeys\..*\.php$#'
            );

            foreach ($files as $file) {
                $file = new File('system/languages/' . $file->getFilename());
                $file->delete();
            }
        }
    }
}
